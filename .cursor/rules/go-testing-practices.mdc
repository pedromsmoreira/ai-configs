---
description: "Go backend testing practices and guidelines"
globs:
  - "**/*_test.go"
alwaysApply: true
---

# Go Testing Practices

For the full TDD workflow (Red-Green-Refactor), see `test-driven-development.mdc`.

## Test Structure

- Use `testify` for assertions
- **Main test functions MUST contain subtests using `t.Run`**
- Each test case should be a subtest within the main test function
- Use individual test functions with descriptive names for different behaviors/scenarios

### Main Test Function Pattern

**Rule**: Every main test function (`TestXxx`) should contain one or more subtests using `t.Run`. The main test function acts as a container for related test cases.

```go
// ✅ GOOD: Main test function contains subtests
func TestNewEmail_WithValidEmail_ReturnsEmail(t *testing.T) {
    t.Run("creates email successfully", func(t *testing.T) {
        email, err := NewEmail("user@example.com")
        assert.NoError(t, err)
        assert.Equal(t, "user@example.com", email.Value())
    })
}

// ✅ GOOD: Main test function with multiple subtests for related scenarios
func TestNewEmail_WithInvalidInput_ReturnsError(t *testing.T) {
    t.Run("returns error for invalid email format", func(t *testing.T) {
        _, err := NewEmail("not-an-email")
        assert.Error(t, err)
        assert.Equal(t, ErrInvalidEmail, err)
    })
    
    t.Run("returns error for empty string", func(t *testing.T) {
        _, err := NewEmail("")
        assert.Error(t, err)
        assert.Equal(t, ErrInvalidEmail, err)
    })
    
    t.Run("returns error for missing @ symbol", func(t *testing.T) {
        _, err := NewEmail("userexample.com")
        assert.Error(t, err)
        assert.Equal(t, ErrInvalidEmail, err)
    })
}

// ❌ BAD: Test function without subtests
func TestNewEmail_WithValidEmail_ReturnsEmail(t *testing.T) {
    email, err := NewEmail("user@example.com")
    assert.NoError(t, err)
    assert.Equal(t, "user@example.com", email.Value())
}

// ❌ BAD: Multiple separate test functions for related scenarios
func TestNewEmail_InvalidFormat(t *testing.T) { /* ... */ }
func TestNewEmail_EmptyString(t *testing.T) { /* ... */ }
func TestNewEmail_MissingAtSymbol(t *testing.T) { /* ... */ }
// Should be combined into one test function with subtests
```

## Unit Tests

- Test one thing at a time
- Use mocks for dependencies
- Test behavior, not implementation
- Keep tests fast (< 100ms each)

```go
// ✅ GOOD: Unit test with mock - main function contains subtest
func TestUserService_GetUser(t *testing.T) {
    t.Run("returns user when found", func(t *testing.T) {
        ctrl := gomock.NewController(t)
        defer ctrl.Finish()
        
        mockRepo := mocks.NewMockUserRepository(ctrl)
        mockRepo.EXPECT().
            GetByID("123").
            Return(&domain.User{ID: "123"}, nil)
        
        service := NewUserService(mockRepo)
        user, err := service.GetUser(context.Background(), "123")
        
        assert.NoError(t, err)
        assert.Equal(t, "123", user.ID)
    })
    
    t.Run("returns error when user not found", func(t *testing.T) {
        ctrl := gomock.NewController(t)
        defer ctrl.Finish()
        
        mockRepo := mocks.NewMockUserRepository(ctrl)
        mockRepo.EXPECT().
            GetByID("999").
            Return(nil, errors.ErrNotFound)
        
        service := NewUserService(mockRepo)
        user, err := service.GetUser(context.Background(), "999")
        
        assert.Error(t, err)
        assert.Nil(t, user)
        assert.Equal(t, errors.ErrNotFound, err)
    })
}
```

## Integration Tests

There are two types of integration tests in this project:

### 1. Service-Level Integration Tests (in `internal/`)

For testing service + repository + database without HTTP:

- Use `testcontainers-go` for database
- Test files next to source code (`*_test.go`)
- Use shared test database
- Clean up after tests

```go
// ✅ GOOD: Service-level integration test (in internal/)
func TestEntityRepository_Create_WithValidEntity_PersistsToDatabase(t *testing.T) {
    t.Run("persists entity and retrieves it", func(t *testing.T) {
        ctx := context.Background()
        db := setupTestDB(t)
        defer db.Close()
        
        repo := repository.NewEntityRepository(db)
        
        entity, err := repo.Create(ctx, testEntity)
        require.NoError(t, err)
        
        found, err := repo.GetByID(ctx, entity.ID)
        require.NoError(t, err)
        assert.Equal(t, entity.ID, found.ID)
    })
}
```

### 2. E2E/API Integration Tests (in `test/`)

For testing complete HTTP workflows with BDD stage patterns:

> **Important**: E2E tests in the `test/` folder **must** follow `11-go-e2e-testing-standards.mdc` for Given-When-Then architecture, stage files, and HTTP/event testing.

```go
// ✅ GOOD: E2E test using BDD stage pattern (in test/)
func TestCreateEntity(t *testing.T) {
    t.Run("when creating an entity returns 201 created", func(t *testing.T) {
        given, when, then := newCreateEntityStage(t)
        
        given.aCreateEntityRequestIsPrepared()
        when.createEntityEndpointIsCalled()
        then.responseShouldHaveStatusCode(http.StatusCreated)
    })
}
```

## Test Naming

- Format: `Test<Function>_<Scenario>_<ExpectedResult>` for main test functions
- Be descriptive about what is being tested
- Use subtests for multiple related scenarios within the same main test function
- Use separate main test functions for different behaviors or distinct test groups

```go
// ✅ GOOD: Descriptive test names with subtests
func TestUser_ChangeEmail_WithValidEmail_UpdatesEmail(t *testing.T) {
    t.Run("updates email successfully", func(t *testing.T) {
        // test implementation
    })
    
    t.Run("updates updated_at timestamp", func(t *testing.T) {
        // test implementation
    })
}

func TestUser_ChangeEmail_WithInvalidInput_ReturnsError(t *testing.T) {
    t.Run("returns error for same email", func(t *testing.T) {
        // test implementation
    })
    
    t.Run("returns error for invalid email format", func(t *testing.T) {
        // test implementation
    })
}

func TestEntityService_Create_WithUnauthorizedUser_ReturnsForbidden(t *testing.T) {
    t.Run("returns forbidden when user lacks permission", func(t *testing.T) {
        // test implementation
    })
}
```

## Test Organization

### File Structure

- Test files next to source: `user_test.go`
- E2E tests in `test/` (NOT `test/integration/`)
- Test utilities in `test/`

### Test Categories

1. **Unit Tests**: Fast, isolated, mock dependencies
2. **Integration Tests**: Test multiple components together

## Test Coverage

- Maintain >80% code coverage
- Focus on critical paths (business logic, error handling)
- Don't chase 100% coverage (test quality > quantity)
- Use coverage reports to find untested code

## Best Practices

### DO

- ✅ Write tests before implementation (TDD)
- ✅ Test behavior, not implementation
- ✅ Keep tests independent and isolated
- ✅ Use descriptive test names
- ✅ Clean up test data
- ✅ Test error cases and edge cases
- ✅ Use mocks for external dependencies

### DON'T

- ❌ Test implementation details
- ❌ Write tests that depend on other tests
- ❌ Ignore flaky tests (fix them)
- ❌ Write tests that are too complex
- ❌ Test framework code
- ❌ Skip error case testing
- ❌ Commit tests that don't pass

## Running Tests

```bash
go test ./...                    # All tests
go test -v ./internal/service    # Verbose output
go test -cover ./...             # With coverage
make test-integration            # Integration tests
```

## Test Data

- Use factories/builders for test data
- Keep test data realistic
- Use constants for shared test data
- Clean up test data after tests

```go
// ✅ GOOD: Test data factory
func NewTestUser(opts ...UserOption) *domain.User {
    user := &domain.User{
        ID:       uuid.New().String(),
        Username: "testuser",
        Email:    "test@example.com",
        UserType: domain.RoleX,  // or appropriate role from domain
    }
    for _, opt := range opts {
        opt(user)
    }
    return user
}
```
