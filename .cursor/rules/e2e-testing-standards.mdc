---
description: BDD testing standards and stage-based architecture for Go tests
globs: test/**/*.go
alwaysApply: false
---

# Go E2E Testing Standards

> **Scope**: This rule applies only to E2E/integration tests in the `test/` folder. For general Go testing practices (unit tests, mocks, coverage), see `go-testing-practices.mdc`.

This project uses a sophisticated BDD-style testing architecture with stage-based patterns for integration tests.

## Architecture Overview

Tests follow a **Given-When-Then** pattern with dedicated stage files:

- `*_test.go` - Test cases and scenarios
- `*_test_stage.go` - Stage struct, constructor, and methods
- `*_test_opts.go` - Functional options for test data setup

## File Organization

### Test File Naming

```go
// ✅ GOOD
tests/create_user_test.go
tests/create_user_test_stage.go
tests/create_user_test_opts.go

tests/update_user_test.go
tests/update_user_test_stage.go
// (opts file optional if not needed)

// ❌ BAD
tests/user_creation_test.go
tests/createUserStage.go
tests/user_test_helpers.go
```

### File Structure

**Test File** (`*_test.go`):
- Contains only test functions with `t.Run()` calls
- Clear, descriptive test names using "when...should..." or "when...returns..." patterns
- No test logic implementation (delegated to stage methods)

**Stage File** (`*_test_stage.go`):
- Stage struct definition with all test dependencies
- Constructor function returning three pointers (given, when, then)
- All stage methods for test phases
- Methods return `*stage` for chaining

**Opts File** (`*_test_opts.go`):
- Functional options for flexible test data setup
- Each option returns `func(*RequestType)`

## Given-When-Then Pattern

```go
// ✅ GOOD
func TestCreateUser(t *testing.T) {
	t.Run("when creating a user returns user with 201 created status code", func(t *testing.T) {
		given, when, then := newCreateUserStage(t)

		given.aCreateUserRequestIsPrepared()
		when.createUserEndpointIsCalled()
		then.responseShouldHaveValidUserAndStatusCode(http.StatusCreated).
			createdEventIsReceived(given.createdUserId)
	})
}

// ❌ BAD - Logic in test function
func TestCreateUser(t *testing.T) {
	t.Run("test create user", func(t *testing.T) {
		request := &CreateUserRequest{FirstName: "test"}
		payload, _ := json.Marshal(request)
		resp, _ := http.Post(url, "application/json", bytes.NewBuffer(payload))
		assert.Equal(t, 201, resp.StatusCode)
	})
}
```

## Stage Constructor

Return three copies of the same stage instance for `given`, `when`, `then`:

```go
// ✅ GOOD
func newCreateUserStage(t *testing.T) (*createUserStage, *createUserStage, *createUserStage) {
	host := getEnvOrDefault("SERVER_HOST", "localhost")
	port := getEnvOrDefault("SERVER_PORT", "8000")
	
	stage := &createUserStage{
		t:    t,
		host: fmt.Sprintf("http://%s:%d", host, port),
		http: &http.Client{Timeout: 30 * time.Second},
	}
	
	// Register cleanup
	t.Cleanup(func() {
		// Cleanup resources
	})
	
	return stage, stage, stage
}

// ❌ BAD - Different instances or incorrect return
func newCreateUserStage(t *testing.T) *createUserStage {
	return &createUserStage{t: t}
}
```

### Environment Configuration

Always use environment variables with sensible defaults:

```go
// ✅ GOOD - Configurable
host := getEnvOrDefault("SERVER_HOST", "localhost")
port := getEnvOrDefault("SERVER_PORT", "8080")
dbHost := getEnvOrDefault("DB_HOST", "localhost")

// Helper function
func getEnvOrDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

// ❌ BAD - Hardcoded
host := "localhost:8000"
```

## Stage Methods

### Naming Conventions

**Given methods** - Setup and preparation:
- Start with `a`, `an`, or descriptive prefix
- Examples: `aUserIsCreatedToBeDeleted()`, `aCreateUserRequestIsPrepared()`

**When methods** - Actions being tested:
- Start with action verb or "the"
- Examples: `createUserEndpointIsCalled()`, `theUserResetsPassword()`

**Then methods** - Assertions and verification:
- Start with assertion description
- Examples: `responseShouldHaveValidUserAndStatusCode()`, `theUserIsUpdatedWithNewFirstName()`

### Method Structure

```go
// ✅ GOOD - Returns *stage for chaining
func (s *createUserStage) aCreateUserRequestIsPrepared(options ...func(*users.CreateUserRequest)) *createUserStage {
	request := &users.CreateUserRequest{
		FirstName: "test",
		LastName:  "test",
		Email:     fmt.Sprintf("test-%s@test.com", uuid.New().String()),
		Password:  "ABCabcabc123!",
	}
	
	for _, option := range options {
		option(request)
	}
	
	s.createRequestBody = request
	s.contentType = applicationJSONContentType
	return s
}

// ❌ BAD - Doesn't return *stage, breaks chaining
func (s *createUserStage) aCreateUserRequestIsPrepared() {
	s.createRequestBody = &users.CreateUserRequest{FirstName: "test"}
}
```

## Functional Options Pattern

Use functional options for flexible test data customization:

```go
// ✅ GOOD - In *_test_opts.go
func WithFirstName(firstName string) func(*users.CreateUserRequest) {
	return func(user *users.CreateUserRequest) {
		user.FirstName = firstName
	}
}

func WithEmail(email string) func(*users.CreateUserRequest) {
	return func(user *users.CreateUserRequest) {
		user.Email = email
	}
}

// Usage in tests
given.aCreateUserRequestIsPrepared(WithFirstName("John"), WithEmail("john@test.com"))
given.aCreateUserRequestIsPrepared(WithFirstName(""))  // Test empty field

// ❌ BAD - Creating multiple setup methods
func (s *createUserStage) aCreateUserRequestIsPreparedWithFirstName(name string) *createUserStage
func (s *createUserStage) aCreateUserRequestIsPreparedWithEmail(email string) *createUserStage
```

## Method Chaining

Enable fluent assertions by returning `*stage`:

```go
// ✅ GOOD - Chained assertions
then.responseShouldHaveValidUserAndStatusCode(http.StatusCreated).
	createdEventIsReceived(given.createdUserId)

then.theResponseShouldBe(http.StatusNoContent).
	and().
	theGetByIdResponseShouldBeNotFound(given.userIDToDelete)

// Helper method for readability
func (s *deleteUserStage) and() *deleteUserStage {
	return s
}
```

## testify/require vs assert

### Use `require` for:
- Network operations (HTTP requests)
- JSON marshaling/unmarshaling
- Reading response bodies
- Critical setup that must succeed
- Operations where continuing makes no sense if they fail

```go
payload, err := json.Marshal(s.createRequestBody)
require.Nil(s.t, err)  // Must succeed to continue

response, err := s.http.Post(url, contentType, bytes.NewBuffer(payload))
require.Nil(s.t, err)  // Must succeed to continue
require.NotNil(s.t, response)  // Need response object
```

### Use `assert` for:
- Status code comparisons
- Value comparisons where seeing all failures helps

```go
assert.Equal(s.t, http.StatusOK, s.response.StatusCode)
assert.Equal(s.t, expectedPage, searchResults.Page)
```

**Rule of Thumb**: If the test cannot meaningfully continue when an assertion fails, use `require`. If you want to see multiple assertion failures in one test run, use `assert`.

## Integration Testing Patterns

### Stage Struct Fields

```go
// ✅ GOOD - Include all dependencies
type createUserStage struct {
	suite.Suite
	t                 *testing.T
	host              string
	http              *http.Client
	response          *http.Response
	createRequestBody *users.CreateUserRequest
	contentType       string
	stream            string
	subject           string
	consumer          jetstream.Consumer
	conn              *nats.Conn
	js                jetstream.JetStream
	createdUserId     uuid.UUID
}
```

## Event Verification

Verify published events using message broker consumers:

```go
// ✅ GOOD
func (s *createUserStage) createdEventIsReceived(id uuid.UUID) *createUserStage {
	msgs, err := s.consumer.Messages()
	require.Nil(s.t, err)
	require.NotNil(s.t, msgs)
	
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()
	
	for {
		select {
		case <-ctx.Done():
			require.Fail(s.t, "Timeout waiting for event")
			return s
		default:
			msg, err := msgs.Next()
			if err != nil {
				if errors.Is(err, nats.ErrTimeout) {
					continue
				}
				require.Nil(s.t, err)
			}
			
			event := new(events.UserCreatedEvent)
			err = json.Unmarshal(msg.Data(), event)
			require.Nil(s.t, err)
			
			if event.UserID == id {
				msg.Ack()
				msgs.Stop()
				return s
			}
			
			msg.Ack()
		}
	}
}
```

## Error Testing

Test error scenarios with proper HTTP error response validation:

```go
// ✅ GOOD
func (s *createUserStage) responseBodyShouldReturnBadRequestError() *createUserStage {
	require.Equal(s.t, http.StatusBadRequest, s.response.StatusCode)
	
	body, err := io.ReadAll(s.response.Body)
	require.Nil(s.t, err)
	require.NotEmpty(s.t, body)
	
	r := new(httpErrors.HttpError)
	err = json.Unmarshal(body, r)
	require.Nil(s.t, err)
	require.NotNil(s.t, r)
	require.NotNil(s.t, r.Message)
	require.NotNil(s.t, r.Details)
	
	return s
}
```

## Test Naming

Write clear, descriptive test names as sentences:

```go
// ✅ GOOD
t.Run("when creating a user returns user with 201 created status code", func(t *testing.T) {
t.Run("when creating a user with empty first name returns 400 bad request status code", func(t *testing.T) {
t.Run("when deleting an existing user returns Status Code 204 No Content", func(t *testing.T) {

// ❌ BAD
t.Run("test create user", func(t *testing.T) {
t.Run("CreateUser_Success", func(t *testing.T) {
```

## Common Patterns

### Creating Test Data with Unique Values

```go
// ✅ GOOD - Ensure unique emails
email := fmt.Sprintf("test-%s@test.com", uuid.New().String())
given.aCreateUserRequestIsPrepared(WithEmail(email))

// ❌ BAD - Hardcoded values cause conflicts
given.aCreateUserRequestIsPrepared(WithEmail("test@test.com"))
```

### Reusing Stages for Setup

```go
// ✅ GOOD - Compose stage methods
func (s *createUserStage) initialUserIsCreatedWithEmail(email string) *createUserStage {
	s.aCreateUserRequestIsPrepared(WithEmail(email))
	s.createUserEndpointIsCalled()
	require.Equal(s.t, http.StatusCreated, s.response.StatusCode)
	return s
}
```

## Content Type Constants

Define content type constants in stage files:

```go
// ✅ GOOD
const (
	applicationJSONContentType      string = "application/json"
	applicationJSONPatchContentType string = "application/merge-patch+json"
)
```

## HTTP Status Code Reference

| Status Code | Constant | Common Use Cases |
|------------|----------|------------------|
| 200 | `http.StatusOK` | Successful GET, PATCH, PUT |
| 201 | `http.StatusCreated` | Successful POST (created) |
| 204 | `http.StatusNoContent` | Successful DELETE |
| 400 | `http.StatusBadRequest` | Validation errors |
| 401 | `http.StatusUnauthorized` | Missing/invalid authentication |
| 403 | `http.StatusForbidden` | Insufficient permissions |
| 404 | `http.StatusNotFound` | Resource doesn't exist |
| 409 | `http.StatusConflict` | Duplicate resource |
| 500 | `http.StatusInternalServerError` | Server errors |

## Common Pitfalls to Avoid

### Pitfall 1: Not Returning `*stage` from Stage Methods

```go
// ❌ BAD - Breaks chaining
func (s *createResourceStage) aCreateResourceRequestIsPrepared() {
	s.createRequestBody = &CreateResourceRequest{Name: "test"}
}

// ✅ GOOD - Enables chaining
func (s *createResourceStage) aCreateResourceRequestIsPrepared() *createResourceStage {
	s.createRequestBody = &CreateResourceRequest{Name: "test"}
	return s
}
```

### Pitfall 2: Hardcoded Configuration Values

```go
// ❌ BAD - Not configurable
host := "localhost:8000"

// ✅ GOOD - Uses environment with defaults
host := getEnvOrDefault("SERVER_HOST", "localhost")
port := getEnvOrDefault("SERVER_PORT", "8080")
```

### Pitfall 3: Using `assert` for Critical Operations

```go
// ❌ BAD - Test continues even if this fails
payload, err := json.Marshal(s.createRequestBody)
assert.Nil(s.t, err)  // Test continues!

// ✅ GOOD - Test stops if critical operation fails
payload, err := json.Marshal(s.createRequestBody)
require.Nil(s.t, err)  // Test stops here if it fails
```

### Pitfall 4: Not Closing Resources

```go
// ❌ BAD - Resource leak
msgs, err := s.consumer.Messages()
for {
	msg, _ := msgs.Next()
	break
}
// msgs.Stop() is missing!

// ✅ GOOD - Clean up resources
msgs, err := s.consumer.Messages()
defer msgs.Stop()
```

### Pitfall 5: Wrong Content Type for PATCH

```go
// ❌ BAD - Wrong content type for PATCH
request.Header.Set("Content-Type", "application/json")

// ✅ GOOD - Use merge-patch for PATCH requests
request.Header.Set("Content-Type", "application/merge-patch+json")
```

### Pitfall 6: Creating Different Stage Instances

```go
// ❌ BAD - Three different instances (breaks state sharing)
func newCreateResourceStage(t *testing.T) (*createResourceStage, *createResourceStage, *createResourceStage) {
	return &createResourceStage{t: t}, &createResourceStage{t: t}, &createResourceStage{t: t}
}

// ✅ GOOD - Same instance three times
func newCreateResourceStage(t *testing.T) (*createResourceStage, *createResourceStage, *createResourceStage) {
	stage := &createResourceStage{t: t, host: "...", http: &http.Client{}}
	return stage, stage, stage
}
```

### Pitfall 7: Not Using t.Cleanup()

```go
// ❌ BAD - Manual cleanup can be missed if test fails early
func newStage(t *testing.T) (*stage, *stage, *stage) {
	conn, _ := nats.Connect("localhost:4222")
	stage := &stage{conn: conn}
	return stage, stage, stage
}

// ✅ GOOD - Cleanup always runs
func newStage(t *testing.T) (*stage, *stage, *stage) {
	conn, _ := nats.Connect("localhost:4222")
	stage := &stage{conn: conn}
	
	t.Cleanup(func() {
		if conn != nil {
			conn.Close()
		}
	})
	
	return stage, stage, stage
}
```

## Debugging Tips

### Test Failing Unexpectedly

1. **Check environment variables**: Verify all services are running and accessible
2. **Print response body**: Add temporary debug logging
   ```go
   body, _ := io.ReadAll(s.response.Body)
   t.Logf("Response: %s", string(body))
   ```
3. **Verify service health**: Ensure API, database, message broker are ready
4. **Check test isolation**: Tests might be interfering with each other

### Event Not Received

1. **Check consumer configuration**: Verify stream, subject, durable name
2. **Increase timeout**: Event might take longer than expected
3. **Check event publishing**: Verify API actually publishes events
4. **Add logging**: Log all received events to debug matching logic

### Database Issues

1. **Connection refused**: Verify database is running and accessible
2. **Record not found**: Check if setup methods actually created the record
3. **Unique constraint violations**: Ensure unique value generation works

## Related Resources

For detailed implementation patterns and examples, see:

- **e2e-test-stage-methods.mdc** - Detailed Given/When/Then method patterns with code examples
- **e2e-test-setup-patterns.mdc** - Complete setup examples for various architectures (HTTP, DB, NATS, Kafka, Redis, etc.)
- **e2e-test-examples.mdc** - 7 practical complete examples including POST, GET, PATCH, DELETE, auth, and event-driven tests
